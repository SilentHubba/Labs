The code uses memoization to solve the problem. It loops through each value from 1 to the amount it is trying to end with. Then it loops through each coin and checks the index at (currentIndex - the value of the coin) to see how many coins it took to get that previous value. Then, it adds 1 to account for the current coin it's adding. It gets the minimum by comparing this value for each coin, then fills the array for each value. The final solution is stored in the last index of the array. It takes O(nm) time, where n is the amount and n is the number of coins in the array. It takes O(n) space.

Also, in the jupyter notebook file, I did a brute force approach. It checks every combination of coins and finds the minimum number it takes to create the given amount. I submitted the other solution at the top because i made up some test cases and this one took too long.
